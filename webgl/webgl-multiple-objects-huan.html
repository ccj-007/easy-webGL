<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>WebGL - Multiple Objects - List</title>
  <link type="text/css" href="resources/webgl-tutorials.css" rel="stylesheet" />
</head>

<body>
  <canvas id="canvas"></canvas>
</body>
<script src="resources/webgl-utils.js"></script>
<script src="resources/m4.js"></script>
<script src="resources/primitives.js"></script>
<!-- vertex shader -->
<script id="vertex-shader-3d" type="x-shader/x-vertex">
attribute vec4 a_position;
attribute vec4 a_color;

uniform mat4 u_matrix;

varying vec4 v_color;

void main() {
  gl_Position = u_matrix * a_position;
  v_color = a_color;
}
</script>
<script id="fragment-shader-3d" type="x-shader/x-fragment">
precision mediump float;
varying vec4 v_color;

uniform vec4 u_colorMult;

void main() {
   gl_FragColor = v_color * u_colorMult;
}
</script>
<script>
  "use strict";
  function makeRandomVertexColors (vertices, options) {
    options = options || {};
    const numElements = vertices.position.numElements;
    const vcolors = webglUtils.createAugmentedTypedArray(4, numElements, Uint8Array);
    function randInt (range) {
      return Math.random() * range | 0;
    }
    const rand = options.rand || function (ndx, channel) {
      return channel < 3 ? randInt(256) : 255;
    };
    vertices.color = vcolors;
    if (vertices.indices) {
      for (let ii = 0; ii < numElements; ++ii) {
        vcolors.push(rand(ii, 0), rand(ii, 1), rand(ii, 2), rand(ii, 3));
      }
    } else {
      const numVertsPerColor = options.vertsPerColor || 3;
      const numSets = numElements / numVertsPerColor;
      for (let ii = 0; ii < numSets; ++ii) {
        const color = [rand(ii, 0), rand(ii, 1), rand(ii, 2), rand(ii, 3)];
        for (let jj = 0; jj < numVertsPerColor; ++jj) {
          vcolors.push(color);
        }
      }
    }
    return vertices;
  }
  function augmentTypedArray (typedArray, numComponents) {
    let cursor = 0;
    typedArray.push = function () {
      for (let ii = 0; ii < arguments.length; ++ii) {
        const value = arguments[ii];
        if (value instanceof Array || (value.buffer && value.buffer instanceof ArrayBuffer)) {
          for (let jj = 0; jj < value.length; ++jj) {
            typedArray[cursor++] = value[jj];
          }
        } else {
          typedArray[cursor++] = value;
        }
      }
    };
    typedArray.reset = function (opt_index) {
      cursor = opt_index || 0;
    };
    typedArray.numComponents = numComponents;
    Object.defineProperty(typedArray, 'numElements', {
      get: function () {
        return this.length / this.numComponents | 0;
      },
    });
    return typedArray;
  }

  function createAugmentedTypedArray (numComponents, numElements, opt_type) {
    const Type = opt_type || Float32Array;
    return augmentTypedArray(new Type(numComponents * numElements), numComponents);
  }

  function deindexVertices (vertices) {
    const indices = vertices.indices;

    const newVertices = {};
    const numElements = indices.length;

    function expandToUnindexed (channel) {
      const srcBuffer = vertices[channel];

      const numComponents = srcBuffer.numComponents;

      const dstBuffer = createAugmentedTypedArray(numComponents, numElements, srcBuffer.constructor);

      // 根据索引点把
      for (let ii = 0; ii < numElements; ++ii) {
        const ndx = indices[ii];
        const offset = ndx * numComponents;
        for (let jj = 0; jj < numComponents; ++jj) {
          dstBuffer.push(srcBuffer[offset + jj]);
        }
      }
      newVertices[channel] = dstBuffer;
    }
    const fn = Object.keys(vertices).filter((name) => name !== 'indices')
    fn.forEach(expandToUnindexed);

    return newVertices;
  }
  function createBufferInfoFromArrays (gl, arrays, opt_mapping) {
    const bufferInfo = {
      attribs: createAttribsFromArrays(gl, arrays, opt_mapping),
    };
    let indices = arrays.indices;
    if (indices) {
      indices = makeTypedArray(indices, 'indices');
      bufferInfo.indices = createBufferFromTypedArray(gl, indices, gl.ELEMENT_ARRAY_BUFFER);
      bufferInfo.numElements = indices.length;
    } else {
      bufferInfo.numElements = getNumElementsFromNonIndexedArrays(arrays);
    }

    return bufferInfo;
  }

  function createFlattenedFunc (vertFunc) {
    return function (gl, ...args) {
      // 返回包含索引、顶点、法线、纹理
      let vertices = vertFunc(...args);
      // 得到索引转换的集合
      vertices = deindexVertices(vertices);

      // 处理颜色
      vertices = makeRandomVertexColors(vertices, {
        vertsPerColor: 6,
        rand: function (ndx, channel) {
          return channel < 3 ? ((128 + Math.random() * 128) | 0) : 255;
        },
      });
      const res = webglUtils.createBufferInfoFromArrays(gl, vertices);
      return res
    };
  }

  function createSphereVertices (
    innerRadians, // 内环半径
    outerRadians,// 外环半径
    xGrids = 20, // 横向格子数量
    yGrids = 20, // 竖向格子数量
    pis = [Math.PI * 0.2, Math.PI * 3, Math.PI * 0.5]
  ) {
    let pLen = pis.length
    const numVertices = (xGrids) * (pLen) * 3;
    const positions = webglUtils.createAugmentedTypedArray(3, numVertices);
    const normals = webglUtils.createAugmentedTypedArray(3, numVertices);
    const texCoords = webglUtils.createAugmentedTypedArray(2, numVertices);
    const numVertsAround = xGrids + 1;
    const indices = webglUtils.createAugmentedTypedArray(3, xGrids * pLen, Uint16Array);
    let pi = 0
    let len = pis.length

    let posList = []
    for (let j = 0; j < 1; j++) {
      pi = pis[j]
      for (let i = 0; i <= xGrids; i++) {
        let angle = pi * (i / xGrids);
        posList.push(
          innerRadians * Math.sin(angle),
          1,
          innerRadians * Math.cos(angle),
        );
        posList.push(
          outerRadians * Math.sin(angle),
          1,
          outerRadians * Math.cos(angle),
        )
      }
    }
    positions.push(...posList)
    console.log(positions);

    let ids = []
    for (let j = 0; j < pLen; j++) {
      let o = pLen * j
      for (let i = 0; i < xGrids; i++) {
        let p0 = i * 2;
        let p1 = i * 2 + 1;
        let p2 = (i + 1) * 2 + 1;
        let p3 = (i + 1) * 2;
        if (i == xGrids - 1) {
          p2 = 1;
          p3 = 0;
        }
        ids.push(p0 + o, p1 + o, p2 + o, p2 + o, p3 + o, p0 + o)
      }
    }
    console.log(ids);
    indices.push(...ids);
    return {
      position: positions,
      normal: normals, // 法线
      texcoord: texCoords, // 纹理
      indices: indices,
    };
  }

  function main () {
    var canvas = document.querySelector("#canvas");
    var gl = canvas.getContext("webgl");
    if (!gl) {
      return;
    }
    canvas.style.width = window.innerWidth + 'px'
    canvas.style.height = window.innerHeight + 'px'

    const createRingWithVertexColorsBufferInfo = createFlattenedFunc(createSphereVertices)

    const sphereBufferInfo = createRingWithVertexColorsBufferInfo(gl, 20, 100, 20, 20);


    var programInfo = webglUtils.createProgramInfo(gl, ["vertex-shader-3d", "fragment-shader-3d"]);

    function degToRad (d) {
      return d * Math.PI / 180;
    }

    var fieldOfViewRadians = degToRad(60);

    var sphereUniforms = {
      u_colorMult: [0.5, 1, 0.5, 1],
      u_matrix: m4.identity(),
    };

    var sphereTranslation = [0, 0, 0];
    var cubeTranslation = [-40, 0, 0];
    var coneTranslation = [40, 0, 0];

    var objectsToDraw = [
      {
        programInfo: programInfo,
        bufferInfo: sphereBufferInfo,
        uniforms: sphereUniforms,
      }
    ];

    function computeMatrix (viewProjectionMatrix, translation, xRotation, yRotation) {
      var matrix = m4.translate(viewProjectionMatrix,
        translation[0],
        translation[1],
        translation[2]);
      matrix = m4.xRotate(matrix, xRotation);
      return m4.yRotate(matrix, yRotation);
    }

    requestAnimationFrame(drawScene);

    // Draw the scene.
    function drawScene (time) {
      time = 0.0005;

      webglUtils.resizeCanvasToDisplaySize(gl.canvas);

      // Tell WebGL how to convert from clip space to pixels
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

      gl.enable(gl.CULL_FACE);
      gl.enable(gl.DEPTH_TEST);

      // Clear the canvas AND the depth buffer.
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      // Compute the projection matrix
      var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
      var projectionMatrix =
        m4.perspective(fieldOfViewRadians, aspect, 1, 2000);

      // Compute the camera's matrix using look at.
      var cameraPosition = [0, 80, 180];
      var target = [0, 0, 0];
      var up = [0, 1, 0];
      var cameraMatrix = m4.lookAt(cameraPosition, target, up);
      // Make a view matrix from the camera matrix.
      var viewMatrix = m4.inverse(cameraMatrix);

      var viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);

      var sphereXRotation = time;
      var sphereYRotation = time;
      var cubeXRotation = -time;
      var cubeYRotation = time;
      var coneXRotation = time;
      var coneYRotation = -time;

      // Compute the matrices for each object.
      sphereUniforms.u_matrix = computeMatrix(
        viewProjectionMatrix,
        sphereTranslation,
        sphereXRotation,
        sphereYRotation);
      // ------ Draw the objects --------

      objectsToDraw.forEach(function (object) {
        var programInfo = object.programInfo;
        var bufferInfo = object.bufferInfo;

        gl.useProgram(programInfo.program);

        // Setup all the needed attributes.
        webglUtils.setBuffersAndAttributes(gl, programInfo, bufferInfo);

        // Set the uniforms.
        webglUtils.setUniforms(programInfo, object.uniforms);

        // Draw
        gl.drawArrays(gl.TRIANGLES, 0, bufferInfo.numElements);
      });

      requestAnimationFrame(drawScene);
    }
  }

  main();
</script>

</html>